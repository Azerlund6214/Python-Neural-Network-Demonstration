import random
import timeit
import matplotlib.pyplot as plt  #графики

import numpy as np

#from Global_vars    import *
#from ALL_print_func import *
#from ALL_study_func import *





  

####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################



###################################

# Сколько сэлем выводить в 1 строке
print_row_len = 3

 
# Порог функции активации
bias = 7 #7  # для 1=7

# Итерации
iter_count = 5000  # 50 мало, 100 более-менее


DECREASE_COUNT = 1
INCREASE_COUNT = 1

###################################

# Самый главный двумерн массив весов
ALL_weights_old = []

buf_array_weights = []


##################################################################
##################################################################
##################################################################



###################################
 
# Цифры (Обучающая выборка)
num0 = list('111101101101111')
num1 = list('001001001001001')
num2 = list('111001111100111')
num3 = list('111001111001111')
num4 = list('101101111001001')
num5 = list('111100111001111')
num6 = list('111100111101111')
num7 = list('111001001001001')
num8 = list('111101111101111')
num9 = list('111101111001111')
 
# Список всех вышеуказанных цифр
ARRAY_ALL_010101 = [num0, num1, num2, num3, num4, num5, num6, num7, num8, num9]



num10 = list('101101101101111')
num11 = list('001001001000001')
num12 = list('110001111100111')
num13 = list('101001111001111')
num14 = list('101100111001001')
num15 = list('111100111000111')
num16 = list('111100111101111')
num17 = list('111001001001001')
num18 = list('111101111101110')
num19 = list('110101111001111')
 
 
ARRAY_ALL_020202 = [num10, num11, num12, num13, num14, num15, num16, num17, num18, num19]

# Виды цифры 2 (Тестовая выборка)
#num21 = list('111001010100111') # 2 1 заменены на 0
#num21 = list('101001010100101') # 4 единицы заменены на 0
#num22 = list('101001100000111') # 4 единицы заменены на 0
#num23 = list('101001010100011') # 4 единицы заменены на 0

#num52 = list('111100010001111')
#num53 = list('111100011001111')
#num54 = list('110100111001111') # Это образцы для ПЯТЕРКИ
#num55 = list('110100111001011')
#num56 = list('111100101001111')











####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################




# m = [ [0 , 1 , 2 , 3 , 4 , 5 ] , ["00" , "01" , "02" , "10" , "11" , "12"  ] ]
# Позволяет выводить любые N-мерные массивы(list) с ЛЮБЫМИ типами данных     ЦВЕТНЫЕ
def UNIV_PRINT_ANY_ARRAY( arr , length_row, msg="def_msg" , recurs_level = 0 , arr_num = 0):

	print( "" )
	#print( "\n" + "#"*25 + " - Start print" )
	print( msg , end="" )
	
	data_type = str( type(arr[0]) )


	if recurs_level != 0: 
		print("Это все элементы mass["+str(arr_num)+"] , тип элементов([0])=" + data_type )
	#else:
	#	print("Тип определен как: ", data_type , end = "" )
	# Не убирать




	
	# Вывод ВСЕГО массива
	if data_type == "<class 'list'>": 
		arr_num = 0
		
		for mas in arr:
			# Рекурсия
			UNIV_PRINT_ANY_ARRAY(mas , length_row , "Вызвана рекурсия." , recurs_level+1 , arr_num) 
			arr_num += 1
			
		return # т к дальше гнать смысла нет





	
	curr_ind = 0
	for elem in arr: # каждый элем



		# Перенос строки
		if (curr_ind) % length_row == 0:
			print ("")
    
 
 
  
    
  
  
  
		# Вывод чисел
		if data_type == "<class 'int'>": 
	
				# Вернет СТРОКУ !!!!
				#elem = GET_COLORED( elem , "weight" )
				#elem = int(elem)
				
				end_sumb = ""
				
				
				
				
				
				
				# 1, 2,..., 9# 2 симв
				if elem >= 0 and elem <= 9:
					print ( "" , GET_COLORED( elem , "weight" ) , end=end_sumb)

				else:  # #-1 ... -9# 2 симв
				
					# -1 ... -9
					if elem <= -1 and elem >= -9:
						print ( GET_COLORED( elem , "weight" ) , end=end_sumb )    
						
					if  elem <= -10 :
						print ( "", GET_COLORED( elem , "weight" ) , end=end_sumb )    
						
					if  elem >= 10:
						print ( " ", GET_COLORED( elem , "weight" ) , end=end_sumb )    
						
						
						
					#else: #  -10 <= x <= 10  # 2 или 3 и более цифры
					#	print ( GET_COLORED( elem , "weight" ) , end=end_sumb )

  
  
  
  
  
  
		
		# Вывод строк (001010101)
		if data_type == "<class 'str'>": 
			# Строка => выводим эталон числа типа 0101101010
			print ( GET_COLORED( elem , "reference") , end=" " )
      
      
      
      
      
      
      
		if data_type == "<class 'float'>": 
			print ( elem , end=" " )
      
      
      
      
      
      
		curr_ind += 1
		# end for
		
		
	#print("\n" + "#"*25 + " - End print" , end = "")
	print( "" )
	return




# Возвращает СТРОКУ!!!!
# num = 1 любое число  или  символ(0/1)    type = weight , reference
def GET_COLORED( num , type="weight" , targ_color = "красный" ):
	
	
	colors = {
	  "черный"   : 30 ,
	  "красный"  : 31,
	  "зеленый"  : 32,
	  "желтый"   : 33,
	  "синий"    : 34,
	  "пурпурный" : 35,
	  "голубой"  : 36,
	  "белый"    : 37
	}
	
	
	####################################################
	if type == "color":
	  return "\x1b["+ str(colors.get(targ_color) ) + "m" + str(num) + "\x1b[0m"
	
	
	####################################################
	# STRING
	if type == "reference":    # эталон (01010101)
			
			if (num == "1"):
				return "\x1b[41m" + num + "\x1b[0m"   # Красный ФОН
			
			if (num == "0"):
				return "\x1b[8m" + num + "\x1b[0m"   # Невидимый
	
	
	
	####################################################
	
	# INT
	if type == "weight":    # Веса  INT

		#num = int(num)

		if num == 0:
			return "\x1b[33m" + str(num) + "\x1b[0m"   # Желтый
			
			
			
			
		#if num >= 1  and  num < bias:
		#	return "\x1b[32m" + str(num) + "\x1b[0m"   # Желтый
			
		#if num >= bias:
		#	return "\x1b[42m" + str(num) + "\x1b[0m"   # Зеленый
		
		if num >= 1:
		 	return "\x1b[42m" + str(num) + "\x1b[0m"   # Зеленый




		minus_bias = bias-bias-bias+1

		# от -1 до  -bias
		if num <= -1 and num >= minus_bias :
			return "\x1b[31m" + str(num) + "\x1b[0m"   # Красный
	
		if num < minus_bias:
			return "\x1b[41m" + str(num) + "\x1b[0m"   # Зеленый
	
	####################################################
	
	if type == "net":    # Суммы  INT   # 1  это 2?  False net =-3
	
		if num <= -1:
			return "\x1b[31m" + str(num) + "\x1b[0m"   # Красный
	
		if num >= 1 and num <= bias-1:
			return "\x1b[33m" + str(num) + "\x1b[0m"   # Желный
	
		if num >= bias:
			return "\x1b[32m" + str(num) + "\x1b[0m"   # Зеленый
	
	
	####################################################
	
	# на всякий случай
	return num




####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################

# Выдаст массив с N рандомнымных чисел в заданном диапазоне
# НЕ юзать three
def GET_arr_random_int( min , max , count , parts = "two" ):

		ret_arr = []

		#print(min)
		#print(max)
		

		for i in range( 0 , count ):
			
			if parts == "one":
				return [random.randint(min, max) for i in range(count)]
				#ret_arr.append( random.randint (min, max) ) # рандом min ... max

			# Идеально ровное распеделение(Все числа выпали одинак кол-во раз)
			if parts == "two":
				
				step = int(max/2)  # при 1,10 => base=9 => step=4 # 1...4 5...9
	
				# диапазон min...max делится на равные(+-1) части между генераторами
				if i%2 == 0: 	ret_arr.append( random.randint ( min , step) ) # рандом
				else:					ret_arr.append( random.randint (step+1, max) ) # рандом 

			
			
			# Последний блок выпадает чаще других (больше всех других на 25%  (все по 6000, он 8300))
			# Все дело в if i % !N!    таких чисел меньше
			if parts == "three":
				
				step = int(max/3)+1 #1...10
				step2 = step*2 #11...20
				step3 = step*3 #21...30
		
				# диапазон min...max делится на равные(+-1) части между генераторами
				if i%3 == 0: 
					ret_arr.append( random.randint ( min , step) ) # рандом 
				else:
					if i%2 == 0:
						ret_arr.append(   random.randint ( step+1 , step2 )   ) # рандом
					else: # этот блок выпадает чаще других
						ret_arr.append(   random.randint ( step2+1, max)   ) # рандом


		'''
		arr_random_int = GET_arr_random_int( 0 , 9 , iter_count , "two" )

		arr_random_int.sort()

		for i in range(0,30):
			print ( i , " = " , arr_random_int.count(i) )


		exit()
		'''


		return ret_arr
 
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
 
def this_num_is(one_number_01, return_net=False , debug_mode=False , buf_array_weights = buf_array_weights):
    
    '''
    if bool(debug_mode):
          print("#"*45)
          #print("this_num_is ", one_number_09)
          print_weight(weights)
          print_01_num(one_number_09)
    '''
    # Рассчитываем взвешенную сумму
    net = 0
    for i in range(15): #Было 15
      
        # old_net = net
      
        net += int(one_number_01[i])*buf_array_weights[i] # 0/1 * его вес(любой)
        
    '''  
        if bool(debug_mode):
           if i%3 == 0:
               print("")
          
           print( one_number_01[i], "*" , weights[i], "=> ",old_net, "+=" , int(one_number_09[i])*int(weights[i]), " == ", net  )
        
    
       
        
    if bool(debug_mode):
        print("\nФинальный net= ", net , "  Решение:", net >= bias , "\n") 
        print("#"*45)
        return str(net >= bias)+" net="+str(net)
        
		'''
    # Превышен ли порог? (Да - сеть думает, что это 2. Нет - сеть думает, что это другая цифра)
    if bool(return_net):
        
        if net >= bias:
          var="TRUE"
        else:
          var="False"
          
        if net == 0:
          return  var + "="+str(net)
        
        if net <= -1:
          return  var + "="+ GET_COLORED(net , "net")
          
        if net >= 1 and net <= bias-1:
          return  var + "="+ GET_COLORED(net , "net")
          
        if net >= bias:
          return  var + "=" + GET_COLORED(net , "net")
          
        
        #print("Конец программы")
          
        
    else:
    
    	return net >= bias

    
    
    
    
    

  
# Уменьшение значений весов, если сеть ошиблась и выдала 1
def decrease_old(number):
    for i in range(15): #Было 15
        # Возбужденный ли вход
        if int(number[i]) == 1:
            # Уменьшаем связанный с ним вес на единицу
            buf_array_weights[i] -= 1
 
 
# Увеличение значений весов, если сеть ошиблась и выдала 0
def increase_old(number):
    for i in range(15):
        # Возбужденный ли вход
        if int(number[i]) == 1:
            # Увеличиваем связанный с ним вес на единицу
            buf_array_weights[i] += 1


 
 
 
 
 
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################


#UNIV_PRINT_ANY_ARRAY( ARRAY_ALL_010101[0] , 3 )
#UNIV_PRINT_ANY_ARRAY( ARRAY_ALL_010101[4] , 3 )

#UNIV_PRINT_ANY_ARRAY( ARRAY_ALL_010101[6] , 3 )
#UNIV_PRINT_ANY_ARRAY( ARRAY_ALL_010101[7] , 3 )




# парам = для чего считаем веса
def CALC_WEIGHTS( str_target_number_010101 , arr_random_int):
 
	# Чистим и заного заполняем нулями(робит)
	buf_array_weights.clear()
	for k in range(15): 
		buf_array_weights.append( 0 )

	#print("Новые буферные веса:", buf_array_weights)

	
	for i in range( iter_count ):

		rand_num = arr_random_int[i] # 0-9
  
  
  
		# сгенр число != целевому
		if rand_num != str_target_number_010101 :
				
			if this_num_is( ARRAY_ALL_010101[rand_num]  ):   # Если сеть выдала True/Да/1, то наказываем ее
				decrease_old( ARRAY_ALL_010101[rand_num] )
      
		else: # Если получилось число 2 или 5
			# Если сеть выдала False/Нет/0, то показываем, что эта цифра - то, что нам нужно
			if not this_num_is( ARRAY_ALL_010101[str_target_number_010101] ):
				increase_old( ARRAY_ALL_010101[str_target_number_010101] )
                
  ############################################################################
	

	return buf_array_weights.copy() 
	 # Без копии передаст прямую ССЫЛКУ!!! и ВСЕ образы будут == ПОСЛЕДНЕМУ состоянию buf_array_weights


			
				

	
	



####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################


# Генерируем рандомные числа
arr_random_int = GET_arr_random_int( 0 , 9 , iter_count , "two" )


####################################################################################
          # ОБУЧЕНИЕ ДЛЯ КАЖДОГО ЧИСЛА


print ("\nОбсчет начат.")



# Учимся на 10 числах			ALL_weights_old[0 ... 9][0 ... 14]
for study_index in range(0,10) : 
	ALL_weights_old.append (CALC_WEIGHTS( study_index , arr_random_int ))


print ("Обсчет закончен.")


####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################


# ПЕЧАТЬ ВСЕХ ВЕСОВ

i = 0
for w in ALL_weights_old : 
	UNIV_PRINT_ANY_ARRAY( w , print_row_len , "Веса для числа "+str(i)+":")
	i += 1
	
	
	
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################



# НЕ УДАЛЯТЬ
# ПРОВЕРКА ДЛЯ ВЕСОВЫХ


#############################################  



print ("Проверка по ЧИСТЫМ числам(увидит ли эталон)")

for i in range(0,10) : 
  TARGET_NUMBER_09 = i

  # Эталон
  TARGET_NUMBER_01_CLEAN = ARRAY_ALL_010101[ TARGET_NUMBER_09 ] # [2]
  #TARGET_NUMBER_09_DAMAGED = list('111001111001111') # Сломаная
  TARGET_NUMBER_09_DAMAGED = ARRAY_ALL_020202[ TARGET_NUMBER_09 ] # [2]


  UNIV_PRINT_ANY_ARRAY( ALL_weights_old[TARGET_NUMBER_09] , print_row_len , "Веса искомого числа:")
  UNIV_PRINT_ANY_ARRAY(   TARGET_NUMBER_01_CLEAN      , print_row_len , "Эталон искомого числа:" )

  UNIV_PRINT_ANY_ARRAY(   TARGET_NUMBER_09_DAMAGED      , print_row_len , "Поврежденное число:" )



  #
  print("\nBias = ", bias )
  for n in range(0,10):
	  print( str(n) , " это ", TARGET_NUMBER_09 ,"? ",
		  this_num_is( TARGET_NUMBER_09_DAMAGED , 1 , 0 , ALL_weights_old[ n ] ))

  print ( "#" * 45 )


# ПРОВЕРКА ДЛЯ ВЕСОВЫХ
# НЕ УДАЛЯТЬ








#print( "#"*40)
print ("\n\n")
print ( "#" * 45 )
print ( "#" * 60 )
print ( "#" * 45 )

#input("Для начала обсчета коэфф введите что-нибудь: ")

print ("\n\n\n") #\n\n\n")

####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################














#print( GET_COLORED("a1a2a3a" , "color" , "красный")  )

print("\x1b[32mКонец программы\x1b[0m")
print("\n\n\n")

####################################################################################
####################################################################################
####################################################################################
####################################################################################
####################################################################################
'''
	# настраиваем детали отрисовки графиков
	plt.figure(figsize=(8, 6))
	plt.title("Installations")
	plt.xlabel("Days")
	plt.ylabel("Installations")
	#plt.xticks([...], [...]) # можно назначить свои тики
	plt.autoscale(tight=True)

	# рисуем исходные точки
	plt.scatter(1, 2)
	
	
	
	#plt.plot(fx, f(fx), linewidth=2)
	plt.plot(1, 2, linewidth=2)
	plt.plot(2, 3, linewidth=2)
	plt.plot(3, 4, linewidth=2)
	
	#plt.legend(legend, loc="upper left")
	plt.grid()
	#plt.savefig('data.png', dpi=50)
	plt.show()
'''
	

'''
Если наша нейросеть правильно распознала 5 или отвергла не 5, то мы ничего не предпринимаем (все ведь замечательно!).

Если нейросеть ошиблась и распознала (неверную цифру) НЕ пятерку как 5, то мы должны ее наказать – мы уменьшаем веса тех связей, через которые прошел сигнал. Другими словами веса, связанные с возбудившимися входами, уменьшаются.

Если нейросеть ошиблась и распознала цифру 5 как НЕ пятерку (как любую другую), то мы должны увеличить все веса, через которые прошел сигнал. Таким образом мы как бы говорим сети, что такие связи, а значит и связанные с ними входы – правильные.
'''
'''
Алг обучения

Подать на входы нейросети цифру в строковом формате.
Если цифра распознана/отвергнута верно, то перейти к шагу 1.
Если сеть ошиблась и распознала неверную цифру как 5, то вычесть из всех связей, связанных с возбудившимися S-элементами единицу.
Если сеть ошиблась и отвергла цифру 5, то добавить единицу ко всем связям, связанным с возбудившимися S-элементами.
'''
'''
Чтобы сеть гарантированно научилась распознавать нужную нам цифру надо соблюсти два условия:

Добиться равномерности показа всех обучающих цифр.
Увеличить общее количество шагов обучения (50 тысяч или 100 тысяч).
'''

''' 

# Прогон по тестовой выборке
#print("Проверка  по ШУМНЫМ числам(смешанные)")
#print("Узнал чистую 2? ", this_num_is(num2))
#print("Узнал 2 в числе 1? ", this_num_is(num21,1))
#print("Узнал 2 в числе 2? ", this_num_is(num22,1))
#print("Узнал 2 в числе 3? ", this_num_is(num23,1,1))
#print("Узнал 2 в числе 4? ", this_num_is(num24,1))
#print("Узнал 2 в числе 5? ", this_num_is(num25,1))
#print("Узнал 2 в числе 6? ", this_num_is(num26,1))


#print("Узнал 21? ", this_num_is(num21,1)) 
#print("Узнал 22? ", this_num_is(num22,1)) 
#print("Узнал 23? ", this_num_is(num23,1)) 

'''


  
'''
# Генерируем случайное число от 0 до 4 
    j1=0 
    for j1 in range(9): 
      rand_num = random.randint (0, 4) 
      j1+=1 
# Генерируем случайное число от 5 до 9 
      j2=0 
    for j2 in range(9): 
      rand_num = random.randint (5, 9) 
      j2+=1 
    # Если получилось НЕ число 2
    if rand_num != 2:
        # Если сеть выдала True/Да/1, то наказываем ее
        if this_num_is(nums[rand_num]):
            decrease(nums[rand_num])
    # Если получилось число 5
    else:
        # Если сеть выдала False/Нет/0, то показываем, что эта цифра - то, что нам нужно
        if not this_num_is(num2):
            increase(num2)
'''







'''
import numpy as np

# Сигмоида 
def nonlin(x,deriv=False):
    if(deriv==True):
        return f(x)*(1-f(x))
    return 1/(1+np.exp(-x))
'''






'''
Списки имеют большой набор функций:
append , extend — добавление;
insert — вставка;
index — найти индекс первого вхождения конкретного элемента;
count — подсчет повторов элемента;
remove , del — удаление элемента;
sort — сортировка;
reverse — реверс;
pop — извлечение элемента;






Если вы строите словарь со словами в виде ключей и количеством вхождений каждого слова в качестве значения, упрощается здесь как:

from collections import defaultdict
d = defaultdict(int)
for w in text.split():
  d[w] += 1




Функции/методы словаря
dict() — создание словаря;
len() — возвращает число пар;
clear() — удаляет все значения из словаря;
copy() — создает псевдокопию словаря;
deepcopy() — создает полную копию словаря;
fromkeys() — создание словаря;
get() — получить значение по ключу;
has_key() — проверка значения по ключу;
items() — возвращает список значений;
iteriyems() — возвращает итератор;
keys() — возвращает список ключей;
iterkeys() — возвращает итератор ключей;
pop() — извлекает значение по ключу;
popitem() — извлекает произвольное значение;
update() — изменяет словарь;
values() — возвращает список значений;
itervalues() — возвращает итератор на список значений.
in — оператор, проверяет наличие значения по ключу;
del — оператор, удаляет пару по ключу;
dict() — конструирует словарь с помощью последовательности.
'''
